---
title: 前端面试题总结01
excerpt: 一些面试题总结
categories:
    - 前端面试题
# math: true
date: 2024-1-3 17:16:00
---
## 前端面试题总结01

## 一、http 状态码301 302 303 307 308之间的区别

### 301状态码：

​	301转向，也叫301重定向或是301跳转，他表示客户端请求的资源被**永久移动**到了一个新的URL。浏览器会自动重定向到新的URL，并且搜索引擎会更新索引来放映这一变化，并且未来的请求都应该被转向到新的URL中。

### 302状态码：

​	302重定向代表**暂时性重定向**。当服务器返回302时，他表示客户端请求的资源暂时被移动一个不同的URL中了。浏览器会重定向到一个新的URL中，但是不会更新索引，因为这是个临时的转移，在未来某个时候请求还是会使用原始的URL。

### 303状态码：

​	303重定向也表示**暂时性重定向**，要求客户端使用GET请求获取新的资源。这个状态码意味着服务器已经创建了一个新的资源，客户端应该使用GET请求获取它。通常用于POST请求后的重定向，以防止客户端重复提交POST请求。

### 307状态码：

​	307也表示**暂时性重定向**，类似于302，但是不同于302的是，307要求客户端的请求方式不变，如果原始请求方式是POST，那么重定向的请求也应该是POST请求。

### 308状态码：

​	同301状态码，为永久重定向，但是区别在于，308要求重定向之后的请求方式不变。

## 二、301和302对于seo来说那个更好

301对seo更加友好。

301永久重定向和302临时重定向对用户来说最终看到的效果是一样的，但是对搜索引擎却不是一样的。当收到301状态码时，搜索引擎只需要重新拉取新URL的资源就行，而不用考虑旧URL的资源。但是如果收到的是302状态码重定向时，搜索引擎理论上也是会只抓取目标URL的资源，但是实际上302临时重定向会引起**网络劫持**的问题。

**网络劫持**：如果内容质量较差的网站A做了302临时重定向到内容质量较高的网站B，客户端请求网站A会得到网站B的资源，这样在不知不觉中，网站B就在为网站A做贡献，网站A的搜索排行提高。

## 三、跨域是什么，如何解决

违反浏览器的**同源策略（域名相同，端口相同，协议相同）**就会产生跨域。

### 解决跨域的方法：

#### 1.document.domain解决主域相同，子域不同的跨域场景

浏览器是通过document.domain来判断两个页面是否同源的，所以只需要设置为相同的document.domain两个页面就可以共享cookie了。

```js
//两个页面都设置为同一个
document.domain='xxxx.com'
```

#### 2.window.postMessage()解决使用iframe下的跨域问题

```js
//父窗口打开一个子窗口向子窗口发消息
var openWindow=window.open('http://a.com','title');
openWindow.postMessage('传递的消息',"http://a.com");
//子窗口接受消息
window.addEventListener('message',function(event){
    //...逻辑
    // event.origin 可以用来验证消息发送者的源
  // event.data 包含了发送的消息
  // event.source 是发送消息的窗口的引用
},false);
```

#### 3.JSONP

由于`<script/>`标签拥有不受同源策略影响的特性，所以利用这一点JSONP可以用来解决跨域。

```html
//原生写法
<script src='http://a.com?callback=dosomething'></script>
    //向服务器http://a.com发送一个请求，查询请求的字符串有一个callback参数，用来指定回调参数的名字
   // 
//处理服务器回调的数据
<script>
	function dosomething(res){
        //服务器回调返回的数据
        console.log(res);
    }
</script>  
```

```js
//ajax写法
$.ajax({
    url:'http://a.com/login',
    type："get",//只支持get请求
    dataType:'jsonp',
    jsonpCallback:'dosomething',//自定义回调函数的函数名
    data:{}
})
```

#### 4.CORS

普通的跨域请求：需要在服务端设置`Access-Control-Allow-Origin`

带cookie的跨域，需要前后端都进行设置

前端设置:

```js
//原生写法
var xhr=new XMLHttpRequest();
//设置cookie
xhr.withCredentials=true;
xhr.open('post','http://a.com/login',true);
xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
xhr.send('user=admin')
xhr.onreadystatechange=function(){
    if(xhr.readyState==4&&xhr.status==200){
        //...处理逻辑
    }
}
```

```js
//ajax写法
$.ajax({
    url:"http://a.com/login",
    type:'get',
    data:{},
    xhrFields:{
        withCredentials:true//设置是否携带cookie
    }，
    crossDomain:true//会让请求头包含跨域的额外信息，但不会包含cookie
})
```

```js
//axios写法
axios.defaults.withCredentials=true
```

#### 5.webpack本地代理

Vue在vue.config.js中添加代理

```js
//vue.config.js
devServer:{
    proxy:{
        '/api':{//代理
            target:"http://a.com",//服务器域名或ip
            changeOrigin:true,//是否开启跨域
            pathRewrite:{
                '^/api':""//把设置的拦截地址替换为空字符串
            }
        }
    }
}
```

#### 6.Nginx代理

​	在打包上线之后进行nginx反向代理

## 四、jsonp有什么缺点

1. 服务端必须要支持JSON数据格式，否则该方法不能解决跨域。
2. 安全性无法保障，JSONP存在安全风险，因为它是完全信任服务器返回的数据的，这导致JSONP容易受到恶意脚本的攻击。
3. 无法抛出错误。由于`<script/>`标签无法抓取和捕获错误，这导致出现报错很难进行调试。
4. 只支持get请求的跨域问题，非常不灵活。

## 五、图片base64和外链的应用场景，各自的优缺点

### 图片base4:

​	应用场景：将图片转换为base64之后，可以将其直接嵌入HTML，CSS或是JS中，不需要额外再发送HTTP请求。

​	优点：

​		1.减少了HTTP请求，有利于提高页面的加载速度。

​		2.减少服务器的请求和压力

​	缺点：

​		1.base64编码之后的图片的文件地址会增加，对于越大型图片，base64编码之后的字符串越多，页面体积就			会越大。

​		2.由于文件是写入页面中的，每次修改都需求修改整个文件。

### 外链：

​	应用场景：大多数图片是采用外链形式的，这些图片都是存储在服务器中。

​	优点：

​		1.外链图片不会增加文件大小。

​		2.更新图片时只需要修改服务器地址或是直接在服务器修改，不需要修改整个文件。

​	缺点：

​		1.增加了HTTP请求，可能会影响页面的加载速度。

​		2.对于图片资源较多的应用，会额外增加HTTP请求的次数，再次拖慢页面加载的速度。

总结：对于大图片，适合使用外链引用；对于体积小且数量多的图片，适合采用base64的形式引用。

## 六、http缓存机制



## 七、https的握手过程

![http握手过程](https://img-blog.csdnimg.cn/img_convert/2844f2a0c7332ee76b45c03327f9e0f4.png)

## 八、set/map的区别

set和map都是常见的数据结构，他们的区别是：

​	Set（集合）：

​		1.集合中每个元素都是唯一的，且集合中的元素没有特定的顺序。

​		2.集合常用于数据的去重

```js
//js中set的常见用法
//创建一个Set
let mySet=new Set();
```



九、hook的局限性

十、setState和hook的区别

十一、decorator的作用，编译后是怎样的

十二、smbol是什么，一般用来做什么

十三、csrf是什么，如何防范

十四、sql注入是什么，如何防范

十五、react调用setState之后会发生什么

十六、nodejs事件循环机制

十七、pm2的原理，有哪些模式

十八、移动端一个元素的拖动如何实现和优化

十九、描述链表的反转如何实现，复杂度是多少

二十、实现instanceOf

二十一、实现一个对象被for of遍历

二十二、实现链表的添加，删除。复杂度是多少

